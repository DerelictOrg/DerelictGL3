/*

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/
module derelict.opengl.extensions.arb_b;

import derelict.opengl.types : usingContexts;
import derelict.opengl.extensions.internal;

// ARB_base_instance <-- Core in GL 4.2
enum ARB_base_instance = "GL_ARB_base_instance";
enum arbBaseInstanceDecls =
q{
extern(System) @nogc nothrow {
    alias da_glDrawArraysInstancedBaseInstance = void function(GLenum, GLint, GLsizei, GLsizei, GLuint);
    alias da_glDrawElementsInstancedBaseInstance = void function(GLenum, GLsizei, GLenum, const(void)*, GLsizei, GLuint);
    alias da_glDrawElementsInstancedBaseVertexBaseInstance = void function(GLenum, GLsizei, GLenum, const(void)*, GLsizei, GLint, GLuint);
}};

enum arbBaseInstanceFuncs =
q{
    da_glDrawArraysInstancedBaseInstance glDrawArraysInstancedBaseInstance;
    da_glDrawElementsInstancedBaseInstance glDrawElementsInstancedBaseInstance;
    da_glDrawElementsInstancedBaseVertexBaseInstance glDrawElementsInstancedBaseVertexBaseInstance;
};

enum arbBaseInstanceLoaderImpl =
q{
    bindGLFunc(cast(void**)&glDrawArraysInstancedBaseInstance, "glDrawArraysInstancedBaseInstance");
    bindGLFunc(cast(void**)&glDrawElementsInstancedBaseInstance, "glDrawElementsInstancedBaseInstance");
    bindGLFunc(cast(void**)&glDrawElementsInstancedBaseVertexBaseInstance, "glDrawElementsInstancedBaseVertexBaseInstance");
};

enum arbBaseInstanceLoader = makeLoader(ARB_base_instance, arbBaseInstanceLoaderImpl, "gl42");
static if(!usingContexts) enum arbBaseInstance = arbBaseInstanceDecls ~ arbBaseInstanceFuncs.makeGShared() ~ arbBaseInstanceLoader;

// ARB_bindless_texture
enum ARB_bindless_texture = "GL_ARB_bindless_texture";
enum arbBindlessTextureDecls =
q{
enum uint GL_UNSIGNED_INT64_ARB = 0x140F;
extern(System) @nogc nothrow {
    alias da_glGetTextureHandleARB = GLuint64 function(GLuint);
    alias da_glGetTextureSamplerHandleARB = GLuint64 function(GLuint,GLuint);
    alias da_glMakeTextureHandleResidentARB = void function(GLuint64);
    alias da_glMakeTextureHandleNonResidentARB = void function(GLuint64);
    alias da_glGetImageHandleARB = GLuint64 function(GLuint,GLint,GLboolean,GLint,GLenum);
    alias da_glMakeImageHandleResidentARB = void function(GLuint64,GLenum);
    alias da_glMakeImageHandleNonResidentARB = void function(GLuint64);
    alias da_glUniformHandleui64ARB = void function(GLint,GLuint64);
    alias da_glUniformHandleui64vARB = void function(GLint,GLsizei,const(GLuint64)*);
    alias da_glProgramUniformHandleui64ARB = void function(GLuint,GLint,GLuint64);
    alias da_glProgramUniformHandleui64vARB = void function(GLuint,GLint,GLsizei,const(GLuint64)*);
    alias da_glIsTextureHandleResidentARB = GLboolean function(GLuint64);
    alias da_glIsImageHandleResidentARB = GLboolean function(GLuint64);
    alias da_glVertexAttribL1ui64ARB = void function(GLuint,GLuint64);
    alias da_glVertexAttribL1ui64vARB = void function(GLuint,const(GLuint64)*);
    alias da_glGetVertexAttribLui64vARB = void function(GLuint,GLenum,GLuint64*);
}};

enum arbBindlessTextureFuncs =
q{
    da_glGetTextureHandleARB glGetTextureHandleARB;
    da_glGetTextureSamplerHandleARB glGetTextureSamplerHandleARB;
    da_glMakeTextureHandleResidentARB glMakeTextureHandleResidentARB;
    da_glMakeTextureHandleNonResidentARB glMakeTextureHandleNonResidentARB;
    da_glGetImageHandleARB glGetImageHandleARB;
    da_glMakeImageHandleResidentARB glMakeImageHandleResidentARB;
    da_glMakeImageHandleNonResidentARB glMakeImageHandleNonResidentARB;
    da_glUniformHandleui64ARB glUniformHandleui64ARB;
    da_glUniformHandleui64vARB glUniformHandleui64vARB;
    da_glProgramUniformHandleui64ARB glProgramUniformHandleui64ARB;
    da_glProgramUniformHandleui64vARB glProgramUniformHandleui64vARB;
    da_glIsTextureHandleResidentARB glIsTextureHandleResidentARB;
    da_glIsImageHandleResidentARB glIsImageHandleResidentARB;
    da_glVertexAttribL1ui64ARB glVertexAttribL1ui64ARB;
    da_glVertexAttribL1ui64vARB glVertexAttribL1ui64vARB;
    da_glGetVertexAttribLui64vARB glGetVertexAttribLui64vARB;
};

enum arbBindlessTextureLoaderImpl =
q{
    bindGLFunc(cast(void**)&glGetTextureHandleARB, "glGetTextureHandleARB");
    bindGLFunc(cast(void**)&glGetTextureSamplerHandleARB, "glGetTextureSamplerHandleARB");
    bindGLFunc(cast(void**)&glMakeTextureHandleResidentARB, "glMakeTextureHandleResidentARB");
    bindGLFunc(cast(void**)&glMakeTextureHandleNonResidentARB, "glMakeTextureHandleNonResidentARB");
    bindGLFunc(cast(void**)&glGetImageHandleARB, "glGetImageHandleARB");
    bindGLFunc(cast(void**)&glMakeImageHandleResidentARB, "glMakeImageHandleResidentARB");
    bindGLFunc(cast(void**)&glMakeImageHandleNonResidentARB, "glMakeImageHandleNonResidentARB");
    bindGLFunc(cast(void**)&glUniformHandleui64ARB, "glUniformHandleui64ARB");
    bindGLFunc(cast(void**)&glUniformHandleui64vARB, "glUniformHandleui64vARB");
    bindGLFunc(cast(void**)&glProgramUniformHandleui64ARB, "glProgramUniformHandleui64ARB");
    bindGLFunc(cast(void**)&glProgramUniformHandleui64vARB, "glProgramUniformHandleui64vARB");
    bindGLFunc(cast(void**)&glIsTextureHandleResidentARB, "glIsTextureHandleResidentARB");
    bindGLFunc(cast(void**)&glIsImageHandleResidentARB, "glIsImageHandleResidentARB");
    bindGLFunc(cast(void**)&glVertexAttribL1ui64ARB, "glVertexAttribL1ui64ARB");
    bindGLFunc(cast(void**)&glVertexAttribL1ui64vARB, "glVertexAttribL1ui64vARB");
    bindGLFunc(cast(void**)&glGetVertexAttribLui64vARB, "glGetVertexAttribLui64vARB");
};

enum arbBindlessTextureLoader = makeExtLoader(ARB_bindless_texture, arbBindlessTextureLoaderImpl);
static if(!usingContexts) enum arbBindlessTexture = arbBindlessTextureDecls ~ arbBindlessTextureFuncs.makeGShared() ~ arbBindlessTextureLoader;

// ARB_blend_func_extended <-- Core in GL 3.3
enum ARB_blend_func_extended = "GL_ARB_blend_func_extended";
enum arbBlendFuncExtendedDecls =
q{
enum : uint
{
    GL_SRC1_COLOR                     = 0x88F9,
    GL_ONE_MINUS_SRC1_COLOR           = 0x88FA,
    GL_ONE_MINUS_SRC1_ALPHA           = 0x88FB,
    GL_MAX_DUAL_SOURCE_DRAW_BUFFERS   = 0x88FC,
}
extern(System) @nogc nothrow {
    alias da_glBindFragDataLocationIndexed = void function(GLuint, GLuint, GLuint, const(GLchar)*);
    alias da_glGetFragDataIndex = GLint function(GLuint, const(GLchar)*);
}};

enum arbBlendFuncExtendedFuncs =
q{
    da_glBindFragDataLocationIndexed glBindFragDataLocationIndexed;
    da_glGetFragDataIndex glGetFragDataIndex;
};

enum arbBlendFuncExtendedLoaderImpl =
q{
    bindGLFunc(cast(void**)&glBindFragDataLocationIndexed, "glBindFragDataLocationIndexed");
    bindGLFunc(cast(void**)&glGetFragDataIndex, "glGetFragDataIndex");
};

enum arbBlendFuncExtendedLoader = makeLoader(ARB_blend_func_extended, arbBlendFuncExtendedLoaderImpl, "gl33");
static if(!usingContexts) enum arbBlendFuncExtended = arbBlendFuncExtendedDecls ~ arbBlendFuncExtendedFuncs.makeGShared() ~ arbBlendFuncExtendedLoader;

// ARB_buffer_storage <-- Core in GL 4.4
enum ARB_buffer_storage = "GL_ARB_buffer_storage";
enum arbBufferStorageDecls =
q{
enum : uint
{
    GL_MAP_PERSISTENT_BIT             = 0x0040,
    GL_MAP_COHERENT_BIT               = 0x0080,
    GL_DYNAMIC_STORAGE_BIT            = 0x0100,
    GL_CLIENT_STORAGE_BIT             = 0x0200,
    GL_CLIENT_MAPPED_BUFFER_BARRIER_BIT = 0x00004000,
    GL_BUFFER_IMMUTABLE_STORAGE       = 0x821F,
    GL_BUFFER_STORAGE_FLAGS           = 0x8220,
}
extern(System) @nogc nothrow {
    alias da_glBufferStorage = void function(GLenum,GLsizeiptr,const(void)*,GLbitfield);
    alias da_glNamedBufferStorageEXT = void function(GLuint,GLsizeiptr,const(void)*,GLbitfield);
}};

enum arbBufferStorageFuncs =
q{
    da_glBufferStorage glBufferStorage;
    da_glNamedBufferStorageEXT glNamedBufferStorageEXT;
};

enum arbBufferStorageLoaderImpl =
q{
    bindGLFunc(cast(void**)&glBufferStorage, "glBufferStorage");
    try { bindGLFunc(cast(void**)&glNamedBufferStorageEXT, "glNamedBufferStorageEXT"); }
    catch(Exception e) {}
};

enum arbBufferStorageLoader = makeLoader(ARB_buffer_storage, arbBufferStorageLoaderImpl, "gl44");
static if(!usingContexts) enum arbBufferStorage = arbBufferStorageDecls ~ arbBufferStorageFuncs.makeGShared() ~ arbBufferStorageLoader;
