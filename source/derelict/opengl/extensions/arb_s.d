/*

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/
module derelict.opengl.extensions.arb_s;

import derelict.opengl.types : usingContexts;
import derelict.opengl.extensions.internal;

// ARB_sample_shading
enum ARB_sample_shading = "GL_ARB_sample_shading";
enum arbSampleShadingDecls =
q{
enum : uint
{
    GL_SAMPLE_SHADING_ARB             = 0x8C36,
    GL_MIN_SAMPLE_SHADING_VALUE_ARB   = 0x8C37,
}
extern(System) @nogc nothrow alias da_glMinSampleShadingARB = void function(GLclampf);
};

enum arbSampleShadingFuncs = `da_glMinSampleShadingARB glMinSampleShadingARB;`;
enum arbSampleShadingLoaderImpl = `bindGLFunc(cast(void**)&glMinSampleShadingARB, "glMinSampleShadingARB");`;
enum arbSampleShadingLoader = makeExtLoader(ARB_sample_shading, arbSampleShadingLoaderImpl);
static if(!usingContexts) enum arbSampleShading = arbSampleShadingDecls ~ arbSampleShadingFuncs ~ arbSampleShadingLoader;

// ARB_shader_atomic_counters <-- Core in GL 4.2
enum ARB_shader_atomic_counters = "GL_ARB_shader_atomic_counters";
enum arbShaderAtomicCountersDecls =
q{
enum : uint {
    GL_ATOMIC_COUNTER_BUFFER          = 0x92C0,
    GL_ATOMIC_COUNTER_BUFFER_BINDING  = 0x92C1,
    GL_ATOMIC_COUNTER_BUFFER_START    = 0x92C2,
    GL_ATOMIC_COUNTER_BUFFER_SIZE     = 0x92C3,
    GL_ATOMIC_COUNTER_BUFFER_DATA_SIZE = 0x92C4,
    GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTERS = 0x92C5,
    GL_ATOMIC_COUNTER_BUFFER_ACTIVE_ATOMIC_COUNTER_INDICES = 0x92C6,
    GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_VERTEX_SHADER = 0x92C7,
    GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_CONTROL_SHADER = 0x92C8,
    GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_TESS_EVALUATION_SHADER = 0x92C9,
    GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_GEOMETRY_SHADER = 0x92CA,
    GL_ATOMIC_COUNTER_BUFFER_REFERENCED_BY_FRAGMENT_SHADER = 0x92CB,
    GL_MAX_VERTEX_ATOMIC_COUNTER_BUFFERS = 0x92CC,
    GL_MAX_TESS_CONTROL_ATOMIC_COUNTER_BUFFERS = 0x92CD,
    GL_MAX_TESS_EVALUATION_ATOMIC_COUNTER_BUFFERS = 0x92CE,
    GL_MAX_GEOMETRY_ATOMIC_COUNTER_BUFFERS = 0x92CF,
    GL_MAX_FRAGMENT_ATOMIC_COUNTER_BUFFERS = 0x92D0,
    GL_MAX_COMBINED_ATOMIC_COUNTER_BUFFERS = 0x92D1,
    GL_MAX_VERTEX_ATOMIC_COUNTERS     = 0x92D2,
    GL_MAX_TESS_CONTROL_ATOMIC_COUNTERS = 0x92D3,
    GL_MAX_TESS_EVALUATION_ATOMIC_COUNTERS = 0x92D4,
    GL_MAX_GEOMETRY_ATOMIC_COUNTERS   = 0x92D5,
    GL_MAX_FRAGMENT_ATOMIC_COUNTERS   = 0x92D6,
    GL_MAX_COMBINED_ATOMIC_COUNTERS   = 0x92D7,
    GL_MAX_ATOMIC_COUNTER_BUFFER_SIZE = 0x92D8,
    GL_MAX_ATOMIC_COUNTER_BUFFER_BINDINGS = 0x92DC,
    GL_ACTIVE_ATOMIC_COUNTER_BUFFERS  = 0x92D9,
    GL_UNIFORM_ATOMIC_COUNTER_BUFFER_INDEX = 0x92DA,
    GL_UNSIGNED_INT_ATOMIC_COUNTER    = 0x92DB,
}
extern(System) @nogc nothrow alias da_glGetActiveAtomicCounterBufferiv = void function(GLuint, GLuint, GLenum, GLint*);
};

enum arbShaderAtomicCountersFuncs = `da_glGetActiveAtomicCounterBufferiv glGetActiveAtomicCounterBufferiv;`;
enum arbShaderAtomicCountersLoaderImpl = `bindGLFunc(cast(void**)&glGetActiveAtomicCounterBufferiv, "glGetActiveAtomicCounterBufferiv");`;
enum arbShaderAtomicCountersLoader = makeLoader(ARB_shader_atomic_counters, arbShaderAtomicCountersLoaderImpl, "gl42");
static if(!usingContexts) enum arbShaderAtomicCounters = arbShaderAtomicCountersDecls ~ arbShaderAtomicCountersFuncs.makeGShared() ~ arbShaderAtomicCountersLoader;

// ARB_shader_image_load_store <-- Core in GL 4.2
enum ARB_shader_image_load_store = "GL_ARB_shader_image_load_store";
enum arbShaderImageLoadStoreDecls =
q{
enum : uint
{
    GL_VERTEX_ATTRIB_ARRAY_BARRIER_BIT = 0x00000001,
    GL_ELEMENT_ARRAY_BARRIER_BIT      = 0x00000002,
    GL_UNIFORM_BARRIER_BIT            = 0x00000004,
    GL_TEXTURE_FETCH_BARRIER_BIT      = 0x00000008,
    GL_SHADER_IMAGE_ACCESS_BARRIER_BIT = 0x00000020,
    GL_COMMAND_BARRIER_BIT            = 0x00000040,
    GL_PIXEL_BUFFER_BARRIER_BIT       = 0x00000080,
    GL_TEXTURE_UPDATE_BARRIER_BIT     = 0x00000100,
    GL_BUFFER_UPDATE_BARRIER_BIT      = 0x00000200,
    GL_FRAMEBUFFER_BARRIER_BIT        = 0x00000400,
    GL_TRANSFORM_FEEDBACK_BARRIER_BIT = 0x00000800,
    GL_ATOMIC_COUNTER_BARRIER_BIT     = 0x00001000,
    GL_ALL_BARRIER_BITS               = 0xFFFFFFFF,
    GL_MAX_IMAGE_UNITS                = 0x8F38,
    GL_MAX_COMBINED_IMAGE_UNITS_AND_FRAGMENT_OUTPUTS = 0x8F39,
    GL_IMAGE_BINDING_NAME             = 0x8F3A,
    GL_IMAGE_BINDING_LEVEL            = 0x8F3B,
    GL_IMAGE_BINDING_LAYERED          = 0x8F3C,
    GL_IMAGE_BINDING_LAYER            = 0x8F3D,
    GL_IMAGE_BINDING_ACCESS           = 0x8F3E,
    GL_IMAGE_1D                       = 0x904C,
    GL_IMAGE_2D                       = 0x904D,
    GL_IMAGE_3D                       = 0x904E,
    GL_IMAGE_2D_RECT                  = 0x904F,
    GL_IMAGE_CUBE                     = 0x9050,
    GL_IMAGE_BUFFER                   = 0x9051,
    GL_IMAGE_1D_ARRAY                 = 0x9052,
    GL_IMAGE_2D_ARRAY                 = 0x9053,
    GL_IMAGE_CUBE_MAP_ARRAY           = 0x9054,
    GL_IMAGE_2D_MULTISAMPLE           = 0x9055,
    GL_IMAGE_2D_MULTISAMPLE_ARRAY     = 0x9056,
    GL_INT_IMAGE_1D                   = 0x9057,
    GL_INT_IMAGE_2D                   = 0x9058,
    GL_INT_IMAGE_3D                   = 0x9059,
    GL_INT_IMAGE_2D_RECT              = 0x905A,
    GL_INT_IMAGE_CUBE                 = 0x905B,
    GL_INT_IMAGE_BUFFER               = 0x905C,
    GL_INT_IMAGE_1D_ARRAY             = 0x905D,
    GL_INT_IMAGE_2D_ARRAY             = 0x905E,
    GL_INT_IMAGE_CUBE_MAP_ARRAY       = 0x905F,
    GL_INT_IMAGE_2D_MULTISAMPLE       = 0x9060,
    GL_INT_IMAGE_2D_MULTISAMPLE_ARRAY = 0x9061,
    GL_UNSIGNED_INT_IMAGE_1D          = 0x9062,
    GL_UNSIGNED_INT_IMAGE_2D          = 0x9063,
    GL_UNSIGNED_INT_IMAGE_3D          = 0x9064,
    GL_UNSIGNED_INT_IMAGE_2D_RECT     = 0x9065,
    GL_UNSIGNED_INT_IMAGE_CUBE        = 0x9066,
    GL_UNSIGNED_INT_IMAGE_BUFFER      = 0x9067,
    GL_UNSIGNED_INT_IMAGE_1D_ARRAY    = 0x9068,
    GL_UNSIGNED_INT_IMAGE_2D_ARRAY    = 0x9069,
    GL_UNSIGNED_INT_IMAGE_CUBE_MAP_ARRAY = 0x906A,
    GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE = 0x906B,
    GL_UNSIGNED_INT_IMAGE_2D_MULTISAMPLE_ARRAY = 0x906C,
    GL_MAX_IMAGE_SAMPLES              = 0x906D,
    GL_IMAGE_BINDING_FORMAT           = 0x906E,
    GL_IMAGE_FORMAT_COMPATIBILITY_TYPE = 0x90C7,
    GL_IMAGE_FORMAT_COMPATIBILITY_BY_SIZE = 0x90C8,
    GL_IMAGE_FORMAT_COMPATIBILITY_BY_CLASS = 0x90C9,
    GL_MAX_VERTEX_IMAGE_UNIFORMS      = 0x90CA,
    GL_MAX_TESS_CONTROL_IMAGE_UNIFORMS = 0x90CB,
    GL_MAX_TESS_EVALUATION_IMAGE_UNIFORMS = 0x90CC,
    GL_MAX_GEOMETRY_IMAGE_UNIFORMS    = 0x90CD,
    GL_MAX_FRAGMENT_IMAGE_UNIFORMS    = 0x90CE,
    GL_MAX_COMBINED_IMAGE_UNIFORMS    = 0x90CF,
}
extern(System) @nogc nothrow {
    alias da_glBindImageTexture = void function(GLuint, GLuint, GLint, GLboolean, GLint, GLenum, GLenum);
    alias da_glMemoryBarrier = void function(GLbitfield);
}};

enum arbShaderImageLoadStoreFuncs =
q{
    da_glBindImageTexture glBindImageTexture;
    da_glMemoryBarrier glMemoryBarrier;
};

enum arbShaderImageLoadStoreLoaderImpl =
q{
    bindGLFunc(cast(void**)&glBindImageTexture, "glBindImageTexture");
    bindGLFunc(cast(void**)&glMemoryBarrier, "glMemoryBarrier");
};

enum arbShaderImageLoadStoreLoader = makeLoader(ARB_shader_image_load_store, arbShaderImageLoadStoreLoaderImpl, "gl42");
static if(!usingContexts) enum arbShaderImageLoadStore = arbShaderImageLoadStoreDecls ~ arbShaderImageLoadStoreFuncs.makeGShared() ~ arbShaderImageLoadStoreLoader;

// ARB_shader_image_size <-- Core in GL 4.3
enum ARB_shader_image_size = "GL_ARB_shader_image_size";
enum arbShaderImageSizeLoader = makeLoader(ARB_shader_image_size, "", "gl43");
static if(!usingContexts) enum arbShaderImageSize = arbShaderImageSizeLoader;

// ARB_shader_stencil_export
enum ARB_shader_stencil_export = "GL_ARB_shader_stencil_export";
enum arbShaderStencilExportLoader = makeExtLoader(ARB_shader_stencil_export);
static if(!usingContexts) enum arbShaderStencilExport = arbShaderStencilExportLoader;

// ARB_shader_storage_buffer_object <-- Core in GL 4.3
enum ARB_shader_storage_buffer_object = "GL_ARB_shader_storage_buffer_object";
enum arbShaderStorageBufferObjectDecls =
q{
enum : uint
{
    GL_SHADER_STORAGE_BUFFER          = 0x90D2,
    GL_SHADER_STORAGE_BUFFER_BINDING  = 0x90D3,
    GL_SHADER_STORAGE_BUFFER_START    = 0x90D4,
    GL_SHADER_STORAGE_BUFFER_SIZE     = 0x90D5,
    GL_MAX_VERTEX_SHADER_STORAGE_BLOCKS = 0x90D6,
    GL_MAX_GEOMETRY_SHADER_STORAGE_BLOCKS = 0x90D7,
    GL_MAX_TESS_CONTROL_SHADER_STORAGE_BLOCKS = 0x90D8,
    GL_MAX_TESS_EVALUATION_SHADER_STORAGE_BLOCKS = 0x90D9,
    GL_MAX_FRAGMENT_SHADER_STORAGE_BLOCKS = 0x90DA,
    GL_MAX_COMPUTE_SHADER_STORAGE_BLOCKS = 0x90DB,
    GL_MAX_COMBINED_SHADER_STORAGE_BLOCKS = 0x90DC,
    GL_MAX_SHADER_STORAGE_BUFFER_BINDINGS = 0x90DD,
    GL_MAX_SHADER_STORAGE_BLOCK_SIZE  = 0x90DE,
    GL_SHADER_STORAGE_BUFFER_OFFSET_ALIGNMENT = 0x90DF,
    GL_SHADER_STORAGE_BARRIER_BIT     = 0x2000,
    GL_MAX_COMBINED_SHADER_OUTPUT_RESOURCES = 0x8F39,
}
extern(System) @nogc nothrow alias da_glShaderStorageBlockBinding = void function(GLuint,GLuint,GLuint);
};

enum arbShaderStorageBufferObjectFuncs = `da_glShaderStorageBlockBinding glShaderStorageBlockBinding;`;
enum arbShaderStorageBufferObjectLoaderImpl = `bindGLFunc(cast(void**)&glShaderStorageBlockBinding, "glShaderStorageBlockBinding");`;
enum arbShaderStorageBufferObjectLoader = makeLoader(ARB_shader_storage_buffer_object, arbShaderStorageBufferObjectLoaderImpl, "gl43");
static if(!usingContexts) enum arbShaderStorageBufferObject = arbShaderStorageBufferObjectDecls ~ arbShaderStorageBufferObjectFuncs.makeGShared() ~ arbShaderStorageBufferObjectLoader;

// ARB_shader_texture_image_samples <-- Core in GL 4.5
enum ARB_shader_texture_image_samples = "GL_ARB_shader_texture_image_samples";
enum arbShaderTextureImageSamplesLoader = makeLoader(ARB_shader_texture_image_samples, "", "gl45");
static if(!usingContexts) enum arbShaderTextureImageSamples = arbShaderTextureImageSamplesLoader;

// ARB_shading_language_420pack <-- Core in GL 4.2
enum ARB_shading_language_420pack = "GL_ARB_shading_language_420pack";
enum arbShadingLanguage420PackLoader = makeLoader(ARB_shading_language_420pack, "", "gl42");
static if(!usingContexts) enum arbShadingLanguage420Pack = arbShadingLanguage420PackLoader;

// ARB_shading_language_include
enum ARB_shading_language_include = "GL_ARB_shading_language_include";
enum arbShadingLanguageIncludeDecls =
q{
enum : uint
{
    GL_SHADER_INCLUDE_ARB             = 0x8DAE,
    GL_NAMED_STRING_LENGTH_ARB        = 0x8DE9,
    GL_NAMED_STRING_TYPE_ARB          = 0x8DEA,
}
extern(System) @nogc nothrow {
    alias da_glNamedStringARB = void function(GLenum, GLint, const(GLchar)*, GLint, const(GLchar)*);
    alias da_glDeleteNamedStringARB = void function(GLint, const(GLchar)*);
    alias da_glCompileShaderIncludeARB = void function(GLuint, GLsizei, const(GLchar)*, const(GLint)*);
    alias da_glIsNamedStringARB = GLboolean function(GLint, const(GLchar)*);
    alias da_glGetNamedStringARB = void function(GLint, const(GLchar)*, GLsizei, GLint*, GLchar*);
    alias da_glGetNamedStringivARB = void function(GLint, const(GLchar)*, GLenum, GLint*);
}};

enum arbShadingLanguageIncludeFuncs =
q{
    da_glNamedStringARB glNamedStringARB;
    da_glDeleteNamedStringARB glDeleteNamedStringARB;
    da_glCompileShaderIncludeARB glCompileShaderIncludeARB;
    da_glIsNamedStringARB glIsNamedStringARB;
    da_glGetNamedStringARB glGetNamedStringARB;
    da_glGetNamedStringivARB glGetNamedStringivARB;
};

enum arbShadingLanguageIncludeLoaderImpl =
q{
    bindGLFunc(cast(void**)&glNamedStringARB, "glNamedStringARB");
    bindGLFunc(cast(void**)&glDeleteNamedStringARB, "glDeleteNamedStringARB");
    bindGLFunc(cast(void**)&glCompileShaderIncludeARB, "glCompileShaderIncludeARB");
    bindGLFunc(cast(void**)&glIsNamedStringARB, "glIsNamedStringARB");
    bindGLFunc(cast(void**)&glGetNamedStringARB, "glGetNamedStringARB");
    bindGLFunc(cast(void**)&glGetNamedStringivARB, "glGetNamedStringivARB");
};

enum arbShadingLanguageIncludeLoader = makeExtLoader(ARB_shading_language_include, arbShadingLanguageIncludeLoaderImpl);
static if(!usingContexts) enum arbShadingLanguageInclude = arbShadingLanguageIncludeDecls ~ arbShadingLanguageIncludeFuncs.makeGShared() ~ arbShadingLanguageIncludeLoader;

// ARB_shading_language_packing
enum ARB_shading_language_packing = "GL_ARB_shading_language_packing";
enum arbShadingLanguagePackingLoader = makeExtLoader(ARB_shading_language_packing);
static if(!usingContexts) enum arbShadingLanguagePacking = arbShadingLanguagePackingLoader;

// ARB_stencil_texturing <-- Core in GL 4.3
enum ARB_stencil_texturing = "GL_ARB_stencil_texturing";
enum arbStencilTexturingDecls = `enum uint GL_DEPTH_STENCIL_TEXTURE_MODE = 0x90EA;`;
enum arbStencilTexturingLoader = makeLoader(ARB_stencil_texturing, "", "gl43");
static if(!usingContexts) enum arbStencilTexturing = arbStencilTexturingDecls ~ arbStencilTexturingLoader;
