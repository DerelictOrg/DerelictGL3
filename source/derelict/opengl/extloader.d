/*

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/
module derelict.opengl.extloader;

import std.array;
import derelict.opengl.types : GLVersion;

alias ExtLoaderFunc = bool function(GLVersion, void delegate(void**,string));

struct ExtLoader(T) {
    static if(is(T == class)) alias RefType = T;
    else alias RefType = T*;

    void initialize(RefType glLoader) { _glLoader = glLoader; }

    void reload()
    {
        import derelict.opengl.versions.base : GL_EXTENSIONS, glGetIntegerv;
        import derelict.opengl.versions.gl3x : GL_NUM_EXTENSIONS, glGetStringi;

        /* The modern style of using glStringi to check for extensions
         results in a high number of calls when testing for numerous
         extensions. This can cause extreme slowdowns in some cases,
         such as when using GLSL-Debugger. The extension cache solves
         that problem.

         Unfortunately, I've discovered that glGetString can actually
         returns null with some drivers when called on a modern core
         context, so checking for 3.0 being loaded is not enough. Instead,
         check if we have a 3.0 context and, if 3.0 is not loaded, explicitly
         load a local copy of glGetStringi.
        */
        if(_glLoader.contextVersion < GLVersion.gl30)
            _glLoader.bindGLFunc(cast(void**)&getStringi, "glGetStringi");
        else
            getStringi = glGetStringi;

        int count;
        glGetIntegerv(GL_NUM_EXTENSIONS, &count);

        _extCache.shrinkTo(0);
        _extCache.reserve(count);

        for(int i=0; i<count; ++i)
            _extCache.put(glGetStringi(GL_EXTENSIONS, i));

        // Now attempt to load every registered extension.
        foreach(name, loader; _registry) {
            if(isSupported(name)) {
                _extState[name] = loader(_glLoader.loadedVersion, &_glLoader.bindGLFunc);
            }
        }
    }

    @property @nogc nothrow
    bool isLoaded(string name)
    {
        if(auto state = (name in _extState)) return *state;
        else return false;
    }

    bool isSupported(string name)
    {
        import core.stdc.string : strcmp, strstr;
        import derelict.opengl.versions.base : GL_EXTENSIONS, glGetString;

        // If the cache is populated, use the modern approach.
        if(_extCache.data.length > 0) {
            foreach(extname; _extCache.data) {
                if(strcmp(extname, name.ptr) == 0)
                    return true;
            }
            return false;
        }
        // Otherwise, use the classic approach.
        else {
            auto extstr = glGetString(GL_EXTENSIONS);
            // TODO Throw and exception here? Perhaps a 'NoExtensionStringException'.
            if(!extstr) return false;

            auto res = strstr(extstr, name.ptr);
            while(res) {
                /* It's possible that the extension name is actually a substring of
                 another extension. If not, then the character following the name in
                 the extension string should be a space (or possibly the null character).
                */
                if(res[name.length] == ' ' || res[name.length] == '\0')
                    return true;
                res = strstr(res + name.length, name.ptr);
            }
            return false;
        }
    }

private:
    Appender!(const(char)*[]) _extCache;
    bool[string] _extState;
    RefType _glLoader;
    da_getStringi getStringi;
}

void registerExtensionLoader(string name, ExtLoaderFunc loader)
{
    _registry[name] = loader;
}

private:
    extern(System) @nogc nothrow alias da_getStringi = const(char)* function(uint, uint);
    ExtLoaderFunc[string] _registry;
