/*

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/

version(None):
private {
    import derelict.util.system;
    import derelict.opengl3.types;
    import derelict.opengl3.constants;
    import derelict.opengl3.internal;
}

enum : uint {
    // ARB_depth_buffer_float
    // ARB_framebuffer_object


    // ARB_framebuffer_sRGB
    GL_FRAMEBUFFER_SRGB               = 0x8DB9,

    // ARB_geometry_shader4
    GL_LINES_ADJACENCY_ARB            = 0x000A,
    GL_LINE_STRIP_ADJACENCY_ARB       = 0x000B,
    GL_TRIANGLES_ADJACENCY_ARB        = 0x000C,
    GL_TRIANGLE_STRIP_ADJACENCY_ARB   = 0x000D,
    GL_PROGRAM_POINT_SIZE_ARB         = 0x8642,
    GL_MAX_GEOMETRY_TEXTURE_IMAGE_UNITS_ARB = 0x8C29,
    GL_FRAMEBUFFER_ATTACHMENT_LAYERED_ARB = 0x8DA7,
    GL_FRAMEBUFFER_INCOMPLETE_LAYER_TARGETS_ARB = 0x8DA8,
    GL_FRAMEBUFFER_INCOMPLETE_LAYER_COUNT_ARB = 0x8DA9,
    GL_GEOMETRY_SHADER_ARB            = 0x8DD9,
    GL_GEOMETRY_VERTICES_OUT_ARB      = 0x8DDA,
    GL_GEOMETRY_INPUT_TYPE_ARB        = 0x8DDB,
    GL_GEOMETRY_OUTPUT_TYPE_ARB       = 0x8DDC,
    GL_MAX_GEOMETRY_VARYING_COMPONENTS_ARB = 0x8DDD,
    GL_MAX_VERTEX_VARYING_COMPONENTS_ARB = 0x8DDE,
    GL_MAX_GEOMETRY_UNIFORM_COMPONENTS_ARB = 0x8DDF,
    GL_MAX_GEOMETRY_OUTPUT_VERTICES_ARB = 0x8DE0,
    GL_MAX_GEOMETRY_TOTAL_OUTPUT_COMPONENTS_ARB = 0x8DE1,

    // ARB_half_float_vertex
    GL_HALF_FLOAT                     = 0x140B,

    // ARB_imaging
    GL_BLEND_COLOR = 0x8005,
    GL_BLEND_EQUATION = 0x8009,

    // ARB_map_buffer_range

    // ARB_texture_compression_rgtc
    GL_COMPRESSED_RED_RGTC1           = 0x8DBB,
    GL_COMPRESSED_SIGNED_RED_RGTC1    = 0x8DBC,
    GL_COMPRESSED_RG_RGTC2            = 0x8DBD,
    GL_COMPRESSED_SIGNED_RG_RGTC2     = 0x8DBE,

    // ARB_texture_rg
    GL_RG                             = 0x8227,
    GL_RG_INTEGER                     = 0x8228,
    GL_R8                             = 0x8229,
    GL_R16                            = 0x822A,
    GL_RG8                            = 0x822B,
    GL_RG16                           = 0x822C,
    GL_R16F                           = 0x822D,
    GL_R32F                           = 0x822E,
    GL_RG16F                          = 0x822F,
    GL_RG32F                          = 0x8230,
    GL_R8I                            = 0x8231,
    GL_R8UI                           = 0x8232,
    GL_R16I                           = 0x8233,
    GL_R16UI                          = 0x8234,
    GL_R32I                           = 0x8235,
    GL_R32UI                          = 0x8236,
    GL_RG8I                           = 0x8237,
    GL_RG8UI                          = 0x8238,
    GL_RG16I                          = 0x8239,
    GL_RG16UI                         = 0x823A,
    GL_RG32I                          = 0x823B,
    GL_RG32UI                         = 0x823C,

    // ARB_vertex_array_object
    // ARB_uniform_buffer_object
    // ARB_copy_buffer

    // ARB_depth_clamp
    GL_DEPTH_CLAMP                    = 0x864F,

    // ARB_provoking_vertex

    // ARB_seamless_cube_map
    GL_TEXTURE_CUBE_MAP_SEAMLESS      = 0x884F,

    // ARB_sync
    // ARB_texture_multisample

    // ARB_sample_shading
    GL_SAMPLE_SHADING_ARB             = 0x8C36,
    GL_MIN_SAMPLE_SHADING_VALUE_ARB   = 0x8C37,

    // ARB_texture_cube_map_array
    GL_TEXTURE_CUBE_MAP_ARRAY_ARB     = 0x9009,
    GL_TEXTURE_BINDING_CUBE_MAP_ARRAY_ARB = 0x900A,
    GL_PROXY_TEXTURE_CUBE_MAP_ARRAY_ARB = 0x900B,
    GL_SAMPLER_CUBE_MAP_ARRAY_ARB     = 0x900C,
    GL_SAMPLER_CUBE_MAP_ARRAY_SHADOW_ARB = 0x900D,
    GL_INT_SAMPLER_CUBE_MAP_ARRAY_ARB = 0x900E,
    GL_UNSIGNED_INT_SAMPLER_CUBE_MAP_ARRAY_ARB = 0x900F,

    // ARB_texture_gather
    GL_MIN_PROGRAM_TEXTURE_GATHER_OFFSET_ARB = 0x8E5E,
    GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET_ARB = 0x8E5F,

    // ARB_shading_language_include
    GL_SHADER_INCLUDE_ARB             = 0x8DAE,
    GL_NAMED_STRING_LENGTH_ARB        = 0x8DE9,
    GL_NAMED_STRING_TYPE_ARB          = 0x8DEA,

    // ARB_texture_compression_bptc
    GL_COMPRESSED_RGBA_BPTC_UNORM_ARB = 0x8E8C,
    GL_COMPRESSED_SRGB_ALPHA_BPTC_UNORM_ARB = 0x8E8D,
    GL_COMPRESSED_RGB_BPTC_SIGNED_FLOAT_ARB = 0x8E8E,
    GL_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_ARB = 0x8E8F,

    // ARB_blend_func_extended

    // ARB_occlusion_query2
    GL_ANY_SAMPLES_PASSED             = 0x8C2F,

    // ARB_sampler_objects

    // ARB_texture_rgb10_a2ui
    GL_RGB10_A2UI                     = 0x906F,

    // ARB_texture_swizzle
    GL_TEXTURE_SWIZZLE_R              = 0x8E42,
    GL_TEXTURE_SWIZZLE_G              = 0x8E43,
    GL_TEXTURE_SWIZZLE_B              = 0x8E44,
    GL_TEXTURE_SWIZZLE_A              = 0x8E45,
    GL_TEXTURE_SWIZZLE_RGBA           = 0x8E46,

    // ARB_timer_query
    GL_TIME_ELAPSED                   = 0x88BF,
    GL_TIMESTAMP                      = 0x8E28,

    // ARB_vertex_type_2_10_10_10_rev
    GL_INT_2_10_10_10_REV             = 0x8D9F,

    // ARB_draw_indirect

    // ARB_gpu_shader5
    GL_GEOMETRY_SHADER_INVOCATIONS    = 0x887F,
    GL_MAX_GEOMETRY_SHADER_INVOCATIONS = 0x8E5A,
    GL_MIN_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5B,
    GL_MAX_FRAGMENT_INTERPOLATION_OFFSET = 0x8E5C,
    GL_FRAGMENT_INTERPOLATION_OFFSET_BITS = 0x8E5D,

    // ARB_gpu_shader_fp64
    // ARB_shader_subroutine
    // ARB_tessellation_shader
    // ARB_transform_feedback2
    // ARB_transform_feedback3
    // ARB_ES2_compatibility
    // ARB_get_program_binary
    // ARB_separate_shader_objects
    // ARB_viewport_array

    // ARB_cl_event
    GL_SYNC_CL_EVENT_ARB              = 0x8240,
    GL_SYNC_CL_EVENT_COMPLETE_ARB     = 0x8241,

    // ARB_debug_output
    GL_DEBUG_OUTPUT_SYNCHRONOUS_ARB   = 0x8242,
    GL_DEBUG_NEXT_LOGGED_MESSAGE_LENGTH_ARB = 0x8243,
    GL_DEBUG_CALLBACK_FUNCTION_ARB    = 0x8244,
    GL_DEBUG_CALLBACK_USER_PARAM_ARB  = 0x8245,
    GL_DEBUG_SOURCE_API_ARB           = 0x8246,
    GL_DEBUG_SOURCE_WINDOW_SYSTEM_ARB = 0x8247,
    GL_DEBUG_SOURCE_SHADER_COMPILER_ARB = 0x8248,
    GL_DEBUG_SOURCE_THIRD_PARTY_ARB   = 0x8249,
    GL_DEBUG_SOURCE_APPLICATION_ARB   = 0x824A,
    GL_DEBUG_SOURCE_OTHER_ARB         = 0x824B,
    GL_DEBUG_TYPE_ERROR_ARB           = 0x824C,
    GL_DEBUG_TYPE_DEPRECATED_BEHAVIOR_ARB = 0x824D,
    GL_DEBUG_TYPE_UNDEFINED_BEHAVIOR_ARB = 0x824E,
    GL_DEBUG_TYPE_PORTABILITY_ARB     = 0x824F,
    GL_DEBUG_TYPE_PERFORMANCE_ARB     = 0x8250,
    GL_DEBUG_TYPE_OTHER_ARB           = 0x8251,
    GL_MAX_DEBUG_MESSAGE_LENGTH_ARB   = 0x9143,
    GL_MAX_DEBUG_LOGGED_MESSAGES_ARB  = 0x9144,
    GL_DEBUG_LOGGED_MESSAGES_ARB      = 0x9145,
    GL_DEBUG_SEVERITY_HIGH_ARB        = 0x9146,
    GL_DEBUG_SEVERITY_MEDIUM_ARB      = 0x9147,
    GL_DEBUG_SEVERITY_LOW_ARB         = 0x9148,

    // ARB_robustness
    GL_CONTEXT_FLAG_ROBUST_ACCESS_BIT_ARB = 0x00000004,
    GL_LOSE_CONTEXT_ON_RESET_ARB      = 0x8252,
    GL_GUILTY_CONTEXT_RESET_ARB       = 0x8253,
    GL_INNOCENT_CONTEXT_RESET_ARB     = 0x8254,
    GL_UNKNOWN_CONTEXT_RESET_ARB      = 0x8255,
    GL_RESET_NOTIFICATION_STRATEGY_ARB = 0x8256,
    GL_NO_RESET_NOTIFICATION_ARB      = 0x8261,

    // ARB_compressed_texture_pixel_storage
    GL_UNPACK_COMPRESSED_BLOCK_WIDTH  = 0x9127,
    GL_UNPACK_COMPRESSED_BLOCK_HEIGHT = 0x9128,
    GL_UNPACK_COMPRESSED_BLOCK_DEPTH  = 0x9129,
    GL_UNPACK_COMPRESSED_BLOCK_SIZE   = 0x912A,
    GL_PACK_COMPRESSED_BLOCK_WIDTH    = 0x912B,
    GL_PACK_COMPRESSED_BLOCK_HEIGHT   = 0x912C,
    GL_PACK_COMPRESSED_BLOCK_DEPTH    = 0x912D,
    GL_PACK_COMPRESSED_BLOCK_SIZE     = 0x912E,

    // ARB_internalformat_query
    // ARB_map_buffer_alignment
    GL_MIN_MAP_BUFFER_ALIGNMENT       = 0x90BC,

    // ARB_shader_atomic_counters
    // ARB_shader_image_load_store
    // ARB_texture_storage


    // ARB_ES3_compatibility
    GL_COMPRESSED_RGB8_ETC2           = 0x9274,
    GL_COMPRESSED_SRGB8_ETC2          = 0x9275,
    GL_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9276,
    GL_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 0x9277,
    GL_COMPRESSED_RGBA8_ETC2_EAC      = 0x9278,
    GL_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 0x9279,
    GL_COMPRESSED_R11_EAC             = 0x9270,
    GL_COMPRESSED_SIGNED_R11_EAC      = 0x9271,
    GL_COMPRESSED_RG11_EAC            = 0x9272,
    GL_COMPRESSED_SIGNED_RG11_EAC     = 0x9273,
    GL_PRIMITIVE_RESTART_FIXED_INDEX  = 0x8D69,
    GL_ANY_SAMPLES_PASSED_CONSERVATIVE = 0x8D6A,
    GL_MAX_ELEMENT_INDEX              = 0x8D6B,

    // ARB_compute_shader
    // KHR_debug

    // ARB_explicit_uniform_location
    GL_MAX_UNIFORM_LOCATIONS = 0x826E,

    // ARB_framebuffer_no_attachments
    // ARB_internalformat_query2
    // ARB_program_interface_query
    // ARB_shader_storage_buffer_object
    // ARB_stencil_texturing
    GL_DEPTH_STENCIL_TEXTURE_MODE = 0x90EA,

    // ARB_texture_buffer_range
    // ARB_texture_view
    // ARB_vertex_attrib_binding
    // ARB_buffer_storage
    // ARB_clear_texture

    // ARB_enhanced_layouts
    GL_LOCATION_COMPONENT             = 0x934A,
    GL_TRANSFORM_FEEDBACK_BUFFER_INDEX = 0x934B,
    GL_TRANSFORM_FEEDBACK_BUFFER_STRIDE = 0x934C,

    // ARB_query_buffer_object
    GL_QUERY_BUFFER                   = 0x9192,
    GL_QUERY_BUFFER_BARRIER_BIT       = 0x00008000,
    GL_QUERY_BUFFER_BINDING           = 0x9193,
    GL_QUERY_RESULT_NO_WAIT           = 0x9194,

    // ARB_texture_mirror_clamp_to_edge
    GL_MIRROR_CLAMP_TO_EDGE           = 0x8743,

    // ARB_clip_control

    // ARB_cull_distance
    GL_MAX_CULL_DISTANCES             = 0x82F9,
    GL_MAX_COMBINED_CLIP_AND_CULL_DISTANCES = 0x82FA,

    // ARB_conditional_render_inverted
    GL_QUERY_WAIT_INVERTED            = 0x8E17,
    GL_QUERY_NO_WAIT_INVERTED         = 0x8E18,
    GL_QUERY_BY_REGION_WAIT_INVERTED  = 0x8E19,
    GL_QUERY_BY_REGION_NO_WAIT_INVERTED = 0x8E1A,

    // KHR_context_flush_control
    GL_CONTEXT_RELEASE_BEHAVIOR       = 0x82FB,
    GL_CONTEXT_RELEASE_BEHAVIOR_FLUSH = 0x82FC,

    // ARB_direct_state_access
    // KHR_robustness
}
private __gshared bool _ARB_framebuffer_sRGB;
@nogc bool ARB_framebuffer_sRGB() nothrow @property { return _ARB_framebuffer_sRGB; }

// ARB_geometry_shader4
extern( System ) @nogc nothrow {
    alias da_glProgramParameteriARB = void function( GLuint, GLenum, GLint );
    alias da_glFramebufferTextureARB = void function( GLuint, GLenum, GLuint, GLint );
    alias da_glFramebufferTextureLayerARB = void function( GLuint, GLenum, GLuint, GLint, GLint );
    alias da_glFramebufferTextureFaceARB = void function( GLuint, GLenum, GLuint, GLint, GLenum );
}

__gshared
{
    da_glProgramParameteriARB glProgramParameteriARB;
    da_glFramebufferTextureARB glFramebufferTextureARB;
    da_glFramebufferTextureLayerARB glFramebufferTextureLayerARB;
    da_glFramebufferTextureFaceARB glFramebufferTextureFaceARB;
}

private __gshared bool _ARB_geometry_shader4;
@nogc bool ARB_geometry_shader4() nothrow @property { return _ARB_geometry_shader4; }
package void load_ARB_geometry_shader4( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glProgramParameteriARB, "glProgramParameteriARB" );
        bindGLFunc( cast( void** )&glFramebufferTextureARB, "glFramebufferTextureARB" );
        bindGLFunc( cast( void** )&glFramebufferTextureLayerARB, "glFramebufferTextureLayerARB" );
        bindGLFunc( cast( void** )&glFramebufferTextureFaceARB, "glFramebufferTextureFaceARB" );
        _ARB_geometry_shader4 = true;
    } catch( Exception e ) {
        _ARB_geometry_shader4 = false;
        if( doThrow ) throw e;
    }
}

private __gshared bool _ARB_half_float_vertex;
@nogc bool ARB_half_float_vertex() nothrow @property { return _ARB_half_float_vertex; }

private __gshared bool _ARB_imaging;
@nogc bool ARB_imaging() nothrow @property { return _ARB_imaging; }

private __gshared bool _ARB_texture_compression_rgtc;
@nogc bool ARB_texture_compression_rgtc() nothrow @property { return _ARB_texture_compression_rgtc; }

private __gshared bool _ARB_texture_rg;
@nogc bool ARB_texture_rg() nothrow @property { return _ARB_texture_rg; }

private __gshared bool _ARB_depth_clamp;
@nogc bool ARB_depth_clamp() nothrow @property { return _ARB_depth_clamp; }

private __gshared bool _ARB_fragment_coord_conventions;
@nogc bool ARB_fragment_coord_conventions() nothrow @property { return _ARB_fragment_coord_conventions; }

private __gshared bool _ARB_seamless_cube_map;
@nogc bool ARB_seamless_cube_map() nothrow @property { return _ARB_seamless_cube_map; }

private __gshared bool _ARB_vertex_array_bgra;
@nogc bool ARB_vertex_array_bgra() nothrow @property { return _ARB_vertex_array_bgra; }

private __gshared bool _ARB_texture_cube_map_array;
@nogc bool ARB_texture_cube_map_array() nothrow @property { return _ARB_texture_cube_map_array; }

private __gshared bool _ARB_texture_gather;
@nogc bool ARB_texture_gather() nothrow @property { return _ARB_texture_gather; }

private __gshared bool _ARB_texture_query_lod;
@nogc bool ARB_texture_query_lod() nothrow @property { return _ARB_texture_query_lod; }

private __gshared bool _ARB_texture_compression_bptc;
@nogc bool ARB_texture_compression_bptc() nothrow @property { return _ARB_texture_compression_bptc; }

private __gshared bool _ARB_explicit_attrib_location;
@nogc bool ARB_explicit_attrib_location() nothrow @property { return _ARB_explicit_attrib_location; }

private __gshared bool _ARB_occlusion_query2;
@nogc bool ARB_occlusion_query2() nothrow @property { return _ARB_occlusion_query2; }

private __gshared bool _ARB_shader_bit_encoding;
@nogc bool ARB_shader_bit_encoding() nothrow @property { return _ARB_shader_bit_encoding; }

private __gshared bool _ARB_texture_rgb10_a2ui;
@nogc bool ARB_texture_rgb10_a2ui() nothrow @property { return _ARB_texture_rgb10_a2ui; }

private __gshared bool _ARB_texture_swizzle;
@nogc bool ARB_texture_swizzle() nothrow @property { return _ARB_texture_swizzle; }

private __gshared bool _ARB_gpu_shader5;
@nogc bool ARB_gpu_shader5() nothrow @property { return _ARB_gpu_shader5; }

private __gshared bool _ARB_texture_buffer_object_rgb32;
@nogc bool ARB_texture_buffer_object_rgb32() nothrow @property { return _ARB_texture_buffer_object_rgb32; }

private __gshared bool _ARB_shader_precision;
@nogc bool ARB_shader_precision() nothrow @property { return _ARB_shader_precision; }

private __gshared bool _ARB_shader_stencil_export;
@nogc bool ARB_shader_stencil_export() nothrow @property { return _ARB_shader_stencil_export; }

private __gshared bool _ARB_shading_language_420pack;
@nogc bool ARB_shading_language_420pack() nothrow @property { return _ARB_shading_language_420pack; }

private __gshared bool _ARB_compressed_texture_pixel_storage;
@nogc bool ARB_compressed_texture_pixel_storage() nothrow @property { return _ARB_compressed_texture_pixel_storage; }

private __gshared bool _ARB_conservative_depth;
@nogc bool ARB_conservative_depth() nothrow @property { return _ARB_conservative_depth; }

private __gshared bool _ARB_map_buffer_alignment;
@nogc bool ARB_map_buffer_alignment() nothrow @property { return _ARB_map_buffer_alignment; }

private __gshared bool _ARB_shading_language_packing;
@nogc bool ARB_shading_language_packing() nothrow @property { return _ARB_shading_language_packing; }

// ARB_framebuffer_object
// ARB_map_buffer_range
// ARB_vertex_array_object
// ARB_uniform_buffer_object
// ARB_copy_buffer
// ARB_draw_elements_base_vertex
// ARB_provoking_vertex
// ARB_sync
// ARB_texture_multisample
// ARB_draw_buffers_blend
extern( System ) @nogc nothrow {
    alias da_glBlendEquationiARB = void function( GLuint, GLenum );
    alias da_glBlendEquationSeparateiARB = void function( GLuint, GLenum, GLenum );
    alias da_glBlendFunciARB = void function( GLuint, GLenum, GLenum );
    alias da_glBlendFuncSeparateiARB = void function( GLuint, GLenum, GLenum, GLenum, GLenum );
}

__gshared {
    da_glBlendEquationiARB glBlendEquationiARB;
    da_glBlendEquationSeparateiARB glBlendEquationSeparateiARB;
    da_glBlendFunciARB glBlendFunciARB;
    da_glBlendFuncSeparateiARB glBlendFuncSeparateiARB;
}

private __gshared bool _ARB_draw_buffers_blend;
@nogc bool ARB_draw_buffers_blend() nothrow @property { return _ARB_draw_buffers_blend; }
package void load_ARB_draw_buffers_blend() {
try {
    bindGLFunc( cast( void** )&glBlendEquationiARB, "glBlendEquationiARB" );
    bindGLFunc( cast( void** )&glBlendEquationSeparateiARB, "glBlendEquationSeparateiARB" );
    bindGLFunc( cast( void** )&glBlendFunciARB, "glBlendFunciARB" );
    bindGLFunc( cast( void** )&glBlendFuncSeparateiARB, "glBlendFuncSeparateiARB" );
        _ARB_draw_buffers_blend = true;
    } catch( Exception e ) {
        _ARB_draw_buffers_blend = false;
    }
}

// ARB_sample_shading
extern( System ) @nogc nothrow alias da_glMinSampleShadingARB = void function( GLclampf );
__gshared da_glMinSampleShadingARB glMinSampleShadingARB;

private __gshared bool _ARB_sample_shading;
@nogc bool ARB_sample_shading() nothrow @property { return _ARB_sample_shading; }
package void load_ARB_sample_shading() {
    try {
        bindGLFunc( cast( void** )&glMinSampleShadingARB, "glMinSampleShadingARB" );
        _ARB_sample_shading = true;
    } catch( Exception e ) {
        _ARB_sample_shading = false;
    }
}

// ARB_shading_language_include
extern( System ) @nogc nothrow {
    alias da_glNamedStringARB = void function( GLenum, GLint, const( GLchar )*, GLint, const( GLchar )* );
    alias da_glDeleteNamedStringARB = void function( GLint, const( GLchar )* );
    alias da_glCompileShaderIncludeARB = void function( GLuint, GLsizei, const( GLchar )*, const( GLint )* );
    alias da_glIsNamedStringARB = GLboolean function( GLint, const( GLchar )* );
    alias da_glGetNamedStringARB = void function( GLint, const( GLchar )*, GLsizei, GLint*, GLchar* );
    alias da_glGetNamedStringivARB = void function( GLint, const( GLchar )*, GLenum, GLint* );
}

__gshared {
    da_glNamedStringARB glNamedStringARB;
    da_glDeleteNamedStringARB glDeleteNamedStringARB;
    da_glCompileShaderIncludeARB glCompileShaderIncludeARB;
    da_glIsNamedStringARB glIsNamedStringARB;
    da_glGetNamedStringARB glGetNamedStringARB;
    da_glGetNamedStringivARB glGetNamedStringivARB;
}

private __gshared bool _ARB_shading_language_include;
@nogc bool ARB_shading_language_include() nothrow @property { return _ARB_shading_language_include; }
package void load_ARB_shading_language_include() {
    try {
        bindGLFunc( cast( void** )&glNamedStringARB, "glNamedStringARB" );
        bindGLFunc( cast( void** )&glDeleteNamedStringARB, "glDeleteNamedStringARB" );
        bindGLFunc( cast( void** )&glCompileShaderIncludeARB, "glCompileShaderIncludeARB" );
        bindGLFunc( cast( void** )&glIsNamedStringARB, "glIsNamedStringARB" );
        bindGLFunc( cast( void** )&glGetNamedStringARB, "glGetNamedStringARB" );
        bindGLFunc( cast( void** )&glGetNamedStringivARB, "glGetNamedStringivARB" );
        _ARB_shading_language_include = true;
    } catch( Exception e ) {
        _ARB_shading_language_include = false;
    }
}

// ARB_blend_func_extended\
// ARB_sampler_objects

// ARB_timer_query
extern( System ) @nogc nothrow {
    alias da_glQueryCounter = void function( GLuint, GLenum );
    alias da_glGetQueryObjecti64v = void function( GLuint, GLenum, GLint64* );
    alias da_glGetQueryObjectui64v = void function( GLuint, GLenum, GLuint64* );
}

__gshared {
    da_glQueryCounter glQueryCounter;
    da_glGetQueryObjecti64v glGetQueryObjecti64v;
    da_glGetQueryObjectui64v glGetQueryObjectui64v;
}

private __gshared bool _ARB_timer_query;
@nogc bool ARB_timer_query() nothrow @property { return _ARB_timer_query; }
void load_ARB_timer_query( bool doThrow = false ) {
    try {
        bindGLFunc( cast( void** )&glQueryCounter, "glQueryCounter" );
        bindGLFunc( cast( void** )&glGetQueryObjecti64v, "glGetQueryObjecti64v" );
        bindGLFunc( cast( void** )&glGetQueryObjectui64v, "glGetQueryObjectui64v" );
        _ARB_timer_query = true;
    } catch( Exception e ) {
        _ARB_timer_query = false;
        if( doThrow ) throw e;
    }
}

// ARB_vertex_type_2_10_10_10_rev
extern( System ) @nogc nothrow {
    alias da_glVertexP2ui = void function( GLenum, GLuint );
    alias da_glVertexP2uiv = void function( GLenum, const( GLuint )* );
    alias da_glVertexP3ui = void function( GLenum, GLuint );
    alias da_glVertexP3uiv = void function( GLenum, const( GLuint )* );
    alias da_glVertexP4ui = void function( GLenum, GLuint );
    alias da_glVertexP4uiv = void function( GLenum, const( GLuint )* );
    alias da_glTexCoordP1ui = void function( GLenum, GLuint );
    alias da_glTexCoordP1uiv = void function( GLenum, const( GLuint )* );
    alias da_glTexCoordP2ui = void function( GLenum, GLuint );
    alias da_glTexCoordP2uiv = void function( GLenum, const( GLuint )* );
    alias da_glTexCoordP3ui = void function( GLenum, GLuint );
    alias da_glTexCoordP3uiv = void function( GLenum, const( GLuint )* );
    alias da_glTexCoordP4ui = void function( GLenum, GLuint );
    alias da_glTexCoordP4uiv = void function( GLenum, const( GLuint )* );
    alias da_glMultiTexCoordP1ui = void function( GLenum, GLenum, GLuint );
    alias da_glMultiTexCoordP1uiv = void function( GLenum, GLenum, const( GLuint )* );
    alias da_glMultiTexCoordP2ui = void function( GLenum, GLenum, GLuint );
    alias da_glMultiTexCoordP2uiv = void function( GLenum, GLenum, const( GLuint )* );
    alias da_glMultiTexCoordP3ui = void function( GLenum, GLenum, GLuint );
    alias da_glMultiTexCoordP3uiv = void function( GLenum, GLenum, const( GLuint )* );
    alias da_glMultiTexCoordP4ui = void function( GLenum, GLenum, GLuint );
    alias da_glMultiTexCoordP4uiv = void function( GLenum, GLenum, const( GLuint )* );
    alias da_glNormalP3ui = void function( GLenum, GLuint );
    alias da_glNormalP3uiv = void function( GLenum, const( GLuint )* );
    alias da_glColorP3ui = void function( GLenum, GLuint );
    alias da_glColorP3uiv = void function( GLenum, const( GLuint )* );
    alias da_glColorP4ui = void function( GLenum, GLuint );
    alias da_glColorP4uiv = void function( GLenum, const( GLuint )* );
    alias da_glSecondaryColorP3ui = void function( GLenum, GLuint );
    alias da_glSecondaryColorP3uiv = void function( GLenum, const( GLuint )* );
    alias da_glVertexAttribP1ui = void function( GLuint, GLenum, GLboolean, GLuint );
    alias da_glVertexAttribP1uiv = void function( GLuint, GLenum, GLboolean, const( GLuint )* );
    alias da_glVertexAttribP2ui = void function( GLuint, GLenum, GLboolean, GLuint );
    alias da_glVertexAttribP2uiv = void function( GLuint, GLenum, GLboolean, const( GLuint )* );
    alias da_glVertexAttribP3ui = void function( GLuint, GLenum, GLboolean, GLuint );
    alias da_glVertexAttribP3uiv = void function( GLuint, GLenum, GLboolean, const( GLuint )* );
    alias da_glVertexAttribP4ui = void function( GLuint, GLenum, GLboolean, GLuint );
    alias da_glVertexAttribP4uiv = void function( GLuint, GLenum, GLboolean, const( GLuint )* );
}

__gshared {
    da_glVertexP2ui glVertexP2ui;
    da_glVertexP2uiv glVertexP2uiv;
    da_glVertexP3ui glVertexP3ui;
    da_glVertexP3uiv glVertexP3uiv;
    da_glVertexP4ui glVertexP4ui;
    da_glVertexP4uiv glVertexP4uiv;
    da_glTexCoordP1ui glTexCoordP1ui;
    da_glTexCoordP1uiv glTexCoordP1uiv;
    da_glTexCoordP2ui glTexCoordP2ui;
    da_glTexCoordP2uiv glTexCoordP2uiv;
    da_glTexCoordP3ui glTexCoordP3ui;
    da_glTexCoordP3uiv glTexCoordP3uiv;
    da_glTexCoordP4ui glTexCoordP4ui;
    da_glTexCoordP4uiv glTexCoordP4uiv;
    da_glMultiTexCoordP1ui glMultiTexCoordP1ui;
    da_glMultiTexCoordP1uiv glMultiTexCoordP1uiv;
    da_glMultiTexCoordP2ui glMultiTexCoordP2ui;
    da_glMultiTexCoordP2uiv glMultiTexCoordP2uiv;
    da_glMultiTexCoordP3ui glMultiTexCoordP3ui;
    da_glMultiTexCoordP3uiv glMultiTexCoordP3uiv;
    da_glMultiTexCoordP4ui glMultiTexCoordP4ui;
    da_glMultiTexCoordP4uiv glMultiTexCoordP4uiv;
    da_glNormalP3ui glNormalP3ui;
    da_glNormalP3uiv glNormalP3uiv;
    da_glColorP3ui glColorP3ui;
    da_glColorP3uiv glColorP3uiv;
    da_glColorP4ui glColorP4ui;
    da_glColorP4uiv glColorP4uiv;
    da_glSecondaryColorP3ui glSecondaryColorP3ui;
    da_glSecondaryColorP3uiv glSecondaryColorP3uiv;
    da_glVertexAttribP1ui glVertexAttribP1ui;
    da_glVertexAttribP1uiv glVertexAttribP1uiv;
    da_glVertexAttribP2ui glVertexAttribP2ui;
    da_glVertexAttribP2uiv glVertexAttribP2uiv;
    da_glVertexAttribP3ui glVertexAttribP3ui;
    da_glVertexAttribP3uiv glVertexAttribP3uiv;
    da_glVertexAttribP4ui glVertexAttribP4ui;
    da_glVertexAttribP4uiv glVertexAttribP4uiv;
}

private __gshared bool _ARB_vertex_type_2_10_10_10_rev;
@nogc bool ARB_vertex_type_2_10_10_10_rev() nothrow @property { return _ARB_vertex_type_2_10_10_10_rev; }
package void load_ARB_vertex_type_2_10_10_10_rev( bool doThrow = false ) {
    try {
        static if( !Derelict_OS_Mac ) {
            bindGLFunc( cast( void** )&glVertexP2ui, "glVertexP2ui" );
            bindGLFunc( cast( void** )&glVertexP2uiv, "glVertexP2uiv" );
            bindGLFunc( cast( void** )&glVertexP3ui, "glVertexP3ui" );
            bindGLFunc( cast( void** )&glVertexP3uiv, "glVertexP3uiv" );
            bindGLFunc( cast( void** )&glVertexP4ui, "glVertexP4ui" );
            bindGLFunc( cast( void** )&glVertexP4uiv, "glVertexP4uiv" );
            bindGLFunc( cast( void** )&glTexCoordP1ui, "glTexCoordP1ui" );
            bindGLFunc( cast( void** )&glTexCoordP1uiv, "glTexCoordP1uiv" );
            bindGLFunc( cast( void** )&glTexCoordP2ui, "glTexCoordP2ui" );
            bindGLFunc( cast( void** )&glTexCoordP2uiv, "glTexCoordP2uiv" );
            bindGLFunc( cast( void** )&glTexCoordP3ui, "glTexCoordP3ui" );
            bindGLFunc( cast( void** )&glTexCoordP3uiv, "glTexCoordP3uiv" );
            bindGLFunc( cast( void** )&glTexCoordP4ui, "glTexCoordP4ui" );
            bindGLFunc( cast( void** )&glTexCoordP4uiv, "glTexCoordP4uiv" );
            bindGLFunc( cast( void** )&glMultiTexCoordP1ui, "glMultiTexCoordP1ui" );
            bindGLFunc( cast( void** )&glMultiTexCoordP1uiv, "glMultiTexCoordP1uiv" );
            bindGLFunc( cast( void** )&glMultiTexCoordP2ui, "glMultiTexCoordP2ui" );
            bindGLFunc( cast( void** )&glMultiTexCoordP2uiv, "glMultiTexCoordP2uiv" );
            bindGLFunc( cast( void** )&glMultiTexCoordP3ui, "glMultiTexCoordP3ui" );
            bindGLFunc( cast( void** )&glMultiTexCoordP3uiv, "glMultiTexCoordP3uiv" );
            bindGLFunc( cast( void** )&glMultiTexCoordP4ui, "glMultiTexCoordP4ui" );
            bindGLFunc( cast( void** )&glMultiTexCoordP4uiv, "glMultiTexCoordP4uiv" );
            bindGLFunc( cast( void** )&glNormalP3ui, "glNormalP3ui" );
            bindGLFunc( cast( void** )&glNormalP3uiv, "glNormalP3uiv" );
            bindGLFunc( cast( void** )&glColorP3ui, "glColorP3ui" );
            bindGLFunc( cast( void** )&glColorP3uiv, "glColorP3uiv" );
            bindGLFunc( cast( void** )&glColorP4ui, "glColorP4ui" );
            bindGLFunc( cast( void** )&glColorP4uiv, "glColorP4uiv" );
            bindGLFunc( cast( void** )&glSecondaryColorP3ui, "glSecondaryColorP3ui" );
            bindGLFunc( cast( void** )&glSecondaryColorP3uiv, "glSecondaryColorP3uiv" );
        }
        bindGLFunc( cast( void** )&glVertexAttribP1ui, "glVertexAttribP1ui" );
        bindGLFunc( cast( void** )&glVertexAttribP1uiv, "glVertexAttribP1uiv" );
        bindGLFunc( cast( void** )&glVertexAttribP2ui, "glVertexAttribP2ui" );
        bindGLFunc( cast( void** )&glVertexAttribP2uiv, "glVertexAttribP2uiv" );
        bindGLFunc( cast( void** )&glVertexAttribP3ui, "glVertexAttribP3ui" );
        bindGLFunc( cast( void** )&glVertexAttribP3uiv, "glVertexAttribP3uiv" );
        bindGLFunc( cast( void** )&glVertexAttribP4ui, "glVertexAttribP4ui" );
        bindGLFunc( cast( void** )&glVertexAttribP4uiv, "glVertexAttribP4uiv" );
        _ARB_vertex_type_2_10_10_10_rev = true;
    } catch( Exception e ) {
        _ARB_vertex_type_2_10_10_10_rev = false;
        if( doThrow ) throw e;
    }
}

// ARB_draw_indirect
// ARB_gpu_shader_fp64
// ARB_shader_subroutine
// ARB_tessellation_shader
// ARB_transform_feedback3
// ARB_ES2_compatibility
// ARB_get_program_binary
// ARB_separate_shader_objects
// ARB_vertex_attrib_64bit
// ARB_viewport_array
extern( System ) @nogc nothrow {
}

__gshared {
}

private __gshared bool _ARB_viewport_array;
@nogc bool ARB_viewport_array() nothrow @property { return _ARB_viewport_array; }
package void load_ARB_viewport_array( bool doThrow = false ) {
try {
        _ARB_viewport_array = true;
    } catch( Exception e ) {
        _ARB_viewport_array = false;
        if( doThrow ) throw e;
    }
}

// ARB_cl_event
extern( System ) @nogc nothrow alias  da_glCreateSyncFromCLeventARB = GLsync function( _cl_context*, _cl_event*, GLbitfield );
__gshared da_glCreateSyncFromCLeventARB glCreateSyncFromCLeventARB;

private __gshared bool _ARB_cl_event;
@nogc bool ARB_cl_event() nothrow @property { return _ARB_cl_event; }
package void load_ARB_cl_event() {
    try {
        bindGLFunc( cast( void** )&glCreateSyncFromCLeventARB, "glCreateSyncFromCLeventARB" );
        _ARB_cl_event = true;
    } catch( Exception e ) {
        _ARB_cl_event = false;
    }
}

// ARB_debug_output
extern( System ) @nogc nothrow {
    alias da_glDebugMessageControlARB = void function( GLenum, GLenum, GLenum, GLsizei, const( GLuint )*, GLboolean );
    alias da_glDebugMessageInsertARB = void function( GLenum, GLenum, GLuint, GLenum, GLsizei, const( GLchar )* );
    alias da_glGetDebugMessageLogARB = void function( GLuint, GLsizei, GLenum*, GLenum*, GLuint*, GLenum*, GLsizei*, GLchar* );
    alias da_glDebugMessageCallbackARB = void function( GLDEBUGPROCARB, const( GLvoid )* );
}

__gshared {
    da_glDebugMessageControlARB glDebugMessageControlARB;
    da_glDebugMessageInsertARB glDebugMessageInsertARB;
    da_glDebugMessageCallbackARB glDebugMessageCallbackARB;
    da_glGetDebugMessageLogARB glGetDebugMessageLogARB;
}

private __gshared bool _ARB_debug_output;
@nogc bool ARB_debug_output() nothrow @property { return _ARB_debug_output; }
package void load_ARB_debug_output() {
    try {
        bindGLFunc( cast( void** )&glDebugMessageControlARB, "glDebugMessageControlARB" );
        bindGLFunc( cast( void** )&glDebugMessageInsertARB, "glDebugMessageInsertARB" );
        bindGLFunc( cast( void** )&glDebugMessageCallbackARB, "glDebugMessageCallbackARB" );
        bindGLFunc( cast( void** )&glGetDebugMessageLogARB, "glGetDebugMessageLogARB" );
        _ARB_debug_output = true;
    } catch( Exception e ) {
        _ARB_debug_output = false;
    }
}

// ARB_robustness
extern( System ) @nogc nothrow {
    alias da_glGetGraphicsResetStatusARB = GLenum function();
    alias da_glGetnMapdvARB = void function( GLenum, GLenum, GLsizei, GLdouble* );
    alias da_glGetnMapfvARB = void function( GLenum, GLenum, GLsizei, GLfloat* );
    alias da_glGetnMapivARB = void function( GLenum, GLenum, GLsizei, GLint* );
    alias da_glGetnPixelMapfvARB = void function( GLenum, GLsizei, GLfloat* );
    alias da_glGetnPixelMapuivARB = void function( GLenum, GLsizei, GLuint* );
    alias da_glGetnPixelMapusvARB = void function( GLenum, GLsizei, GLushort* );
    alias da_glGetnPolygonStippleARB = void function( GLsizei, GLubyte* );
    alias da_glGetnColorTableARB = void function( GLenum, GLenum, GLenum, GLsizei, GLvoid* );
    alias da_glGetnConvolutionFilterARB = void function( GLenum, GLenum, GLenum, GLsizei, GLvoid* );
    alias da_glGetnSeparableFilterARB = void function( GLenum, GLenum, GLenum, GLsizei, GLvoid*, GLsizei, GLvoid*, GLvoid* );
    alias da_glGetnHistogramARB = void function( GLenum, GLboolean, GLenum, GLenum, GLsizei, GLvoid* );
    alias da_glGetnMinmaxARB = void function( GLenum, GLboolean, GLenum, GLenum, GLsizei, GLvoid* );
    alias da_glGetnTexImageARB = void function( GLenum, GLint, GLenum, GLenum, GLsizei, GLvoid* );
    alias da_glReadnPixelsARB = void function( GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, GLsizei, GLvoid* );
    alias da_glGetnCompressedTexImageARB = void function( GLenum, GLint, GLsizei, GLvoid* );
    alias da_glGetnUniformfvARB = void function( GLuint, GLint, GLsizei, GLfloat* );
    alias da_glGetnUniformivARB = void function( GLuint, GLint, GLsizei, GLint* );
    alias da_glGetnUniformuivARB = void function( GLuint, GLint, GLsizei, GLuint* );
    alias da_glGetnUniformdvARB = void function( GLuint, GLint, GLsizei, GLdouble* );
}

__gshared {
    da_glGetGraphicsResetStatusARB glGetGraphicsResetStatusARB;
    da_glGetnMapdvARB glGetnMapdvARB;
    da_glGetnMapfvARB glGetnMapfvARB;
    da_glGetnMapivARB glGetnMapivARB;
    da_glGetnPixelMapfvARB glGetnPixelMapfvARB;
    da_glGetnPixelMapuivARB glGetnPixelMapuivARB;
    da_glGetnPixelMapusvARB glGetnPixelMapusvARB;
    da_glGetnPolygonStippleARB glGetnPolygonStippleARB;
    da_glGetnColorTableARB glGetnColorTableARB;
    da_glGetnConvolutionFilterARB glGetnConvolutionFilterARB;
    da_glGetnSeparableFilterARB glGetnSeparableFilterARB;
    da_glGetnHistogramARB glGetnHistogramARB;
    da_glGetnMinmaxARB glGetnMinmaxARB;
    da_glGetnTexImageARB glGetnTexImageARB;
    da_glReadnPixelsARB glReadnPixelsARB;
    da_glGetnCompressedTexImageARB glGetnCompressedTexImageARB;
    da_glGetnUniformfvARB glGetnUniformfvARB;
    da_glGetnUniformivARB glGetnUniformivARB;
    da_glGetnUniformuivARB glGetnUniformuivARB;
    da_glGetnUniformdvARB glGetnUniformdvARB;
}

private __gshared bool _ARB_robustness;
@nogc bool ARB_robustness() nothrow @property { return _ARB_robustness; }
package void load_ARB_robustness() {
    try {
        bindGLFunc( cast( void** )&glGetGraphicsResetStatusARB, "glGetGraphicsResetStatusARB" );
        bindGLFunc( cast( void** )&glGetnMapdvARB, "glGetnMapdvARB" );
        bindGLFunc( cast( void** )&glGetnMapfvARB, "glGetnMapfvARB" );
        bindGLFunc( cast( void** )&glGetnMapivARB, "glGetnMapivARB" );
        bindGLFunc( cast( void** )&glGetnPixelMapfvARB, "glGetnPixelMapfvARB" );
        bindGLFunc( cast( void** )&glGetnPixelMapuivARB, "glGetnPixelMapuivARB" );
        bindGLFunc( cast( void** )&glGetnPixelMapusvARB, "glGetnPixelMapusvARB" );
        bindGLFunc( cast( void** )&glGetnPolygonStippleARB, "glGetnPolygonStippleARB" );
        bindGLFunc( cast( void** )&glGetnColorTableARB, "glGetnColorTableARB" );
        bindGLFunc( cast( void** )&glGetnConvolutionFilterARB, "glGetnConvolutionFilterARB" );
        bindGLFunc( cast( void** )&glGetnSeparableFilterARB, "glGetnSeparableFilterARB" );
        bindGLFunc( cast( void** )&glGetnHistogramARB, "glGetnHistogramARB" );
        bindGLFunc( cast( void** )&glGetnMinmaxARB, "glGetnMinmaxARB" );
        bindGLFunc( cast( void** )&glGetnTexImageARB, "glGetnTexImageARB" );
        bindGLFunc( cast( void** )&glReadnPixelsARB, "glReadnPixelsARB" );
        bindGLFunc( cast( void** )&glGetnCompressedTexImageARB, "glGetnCompressedTexImageARB" );
        bindGLFunc( cast( void** )&glGetnCompressedTexImageARB, "glGetnCompressedTexImageARB" );
        bindGLFunc( cast( void** )&glGetnUniformfvARB, "glGetnUniformfvARB" );
        bindGLFunc( cast( void** )&glGetnUniformivARB, "glGetnUniformivARB" );
        bindGLFunc( cast( void** )&glGetnUniformuivARB, "glGetnUniformuivARB" );
        bindGLFunc( cast( void** )&glGetnUniformdvARB, "glGetnUniformdvARB" );
        _ARB_robustness = true;
    } catch( Exception e ) {
        _ARB_robustness = false;
    }
}

// ARB_base_instance
// ARB_transform_feedback_instanced
// ARB_internalformat_query

// ARB_shader_atomic_counters
// ARB_shader_image_load_store
// ARB_texture_storage
// ARB_array_of_arrays
private __gshared bool _ARB_array_of_arrays;
@nogc bool ARB_array_of_arrays() nothrow @property { return _ARB_array_of_arrays; }

// ARB_fragment_layer_viewport
private __gshared bool _ARB_fragment_layer_viewport;
@nogc bool ARB_fragment_layer_viewport() nothrow @property { return _ARB_fragment_layer_viewport; }

// ARB_shader_image_size
private __gshared bool _ARB_shader_image_size;
@nogc bool ARB_shader_image_size() nothrow @property { return _ARB_shader_image_size; }

// ARB_ES3_compatibility
private __gshared bool _ARB_ES3_compatibility;
@nogc bool ARB_ES3_compatibility() nothrow @property { return _ARB_ES3_compatibility; }

// ARB_clear_buffer_object
// ARB_compute_shader
// ARB_copy_image
// KHR_debug

// ARB_explicit_uniform_location
private __gshared bool _ARB_explicit_uniform_location;
@nogc bool ARB_explicit_uniform_location() nothrow @property { return _ARB_explicit_uniform_location; }

// ARB_framebuffer_no_attachments
// ARB_internalformat_query2
// ARB_invalidate_subdata
// ARB_multi_draw_indirect
// ARB_program_interface_query
// ARB_robust_buffer_access_behavior
private __gshared bool _ARB_robust_buffer_access_behavior;
@nogc bool ARB_robust_buffer_access_behavior() nothrow @property { return _ARB_robust_buffer_access_behavior; }

// ARB_shader_storage_buffer_object
extern( System )
__gshared
private __gshared bool _ARB_shader_storage_buffer_object;
@nogc bool ARB_shader_storage_buffer_object() nothrow @property { return _ARB_shader_storage_buffer_object; }
package void load_ARB_shader_storage_buffer_object( bool doThrow = false ) {
    try {

        _ARB_shader_storage_buffer_object = true;
    } catch( Exception e ) {
        _ARB_shader_storage_buffer_object = false;
        if( doThrow ) throw e;
    }
}

// ARB_stencil_texturing
private __gshared bool _ARB_stencil_texturing;
@nogc bool ARB_stencil_texturing() nothrow @property { return _ARB_stencil_texturing; }

// ARB_texture_buffer_range
// ARB_texture_query_levels
private __gshared bool _ARB_texture_query_levels;
@nogc bool ARB_texture_query_levels() nothrow @property { return _ARB_texture_query_levels; }

// ARB_texture_storage_multisample
// ARB_texture_view
// ARB_vertex_attrib_binding
extern( System ) @nogc nothrow {
}

__gshared {
}

private __gshared bool _ARB_vertex_attrib_binding;
@nogc bool ARB_vertex_attrib_binding() nothrow @property { return _ARB_vertex_attrib_binding; }
package void load_ARB_vertex_attrib_binding( bool doThrow = false ) {
try {
    } catch( Exception e ) {
        _ARB_vertex_attrib_binding = false;
        if( doThrow ) throw e;
    }
}

// ARB_buffer_storage
// ARB_clear_texture
// ARB_enhanced_layouts
private __gshared bool _ARB_enhanced_layouts;
@nogc bool ARB_enhanced_layouts() nothrow @property { return _ARB_enhanced_layouts; }

// ARB_multi_bind
// ARB_query_buffer_object
private __gshared bool _ARB_query_buffer_object;
@nogc bool ARB_query_buffer_object() nothrow @property { return _ARB_query_buffer_object; }

// ARB_texture_mirror_clamp_to_edge
private __gshared bool _ARB_texture_mirror_clamp_to_edge;
@nogc bool ARB_texture_mirror_clamp_to_edge() nothrow @property { return _ARB_texture_mirror_clamp_to_edge; }

// ARB_texture_stencil8
private __gshared bool _ARB_texture_stencil8;
@nogc bool ARB_texture_stencil8() nothrow @property { return _ARB_texture_stencil8; }

// ARB_vertex_type_10f_11f_11f_rev
private __gshared bool _ARB_vertex_type_10f_11f_11f_rev;
@nogc bool ARB_vertex_type_10f_11f_11f_rev() nothrow @property { return _ARB_vertex_type_10f_11f_11f_rev; }

// ARB_clip_control
// ARB_cull_distance
private __gshared bool _ARB_cull_distance;
@nogc bool ARB_cull_distance() nothrow @property { return _ARB_cull_distance; }

// ARB_ES3_1_compatibility
extern( System ) @nogc nothrow alias da_glMemoryBarrierByRegion = void function( GLbitfield );
__gshared
private __gshared bool _ARB_ES3_1_compatibility;
@nogc bool ARB_ES3_1_compatibility() nothrow @property { return _ARB_ES3_1_compatibility; }
package void load_ARB_ES3_1_compatibility( bool doThrow = false ) {
    try {

        _ARB_ES3_1_compatibility = true;
    } catch( Exception e ) {
        _ARB_ES3_1_compatibility = false;
        if( doThrow ) throw e;
    }
}

// ARB_conditional_render_inverted
private __gshared bool _ARB_conditional_render_inverted;
@nogc bool ARB_conditional_render_inverted() nothrow @property { return _ARB_conditional_render_inverted; }

// KHR_context_flush_control
private __gshared bool _KHR_context_flush_control;
@nogc bool KHR_context_flush_control() nothrow @property { return _KHR_context_flush_control; }

// ARB_derivative_control
private __gshared bool _ARB_derivative_control;
@nogc bool ARB_derivative_control() nothrow @property { return _ARB_derivative_control; }

// ARB_direct_state_access
// ARB_get_texture_sub_image
extern( System ) @nogc nothrow {
}

__gshared {
}

private __gshared bool _ARB_get_texture_sub_image;
@nogc bool ARB_get_texture_sub_image() nothrow @property { return _ARB_get_texture_sub_image; }
package void load_ARB_get_texture_sub_image( bool doThrow = false ) {
try {
        _ARB_get_texture_sub_image = true;
    } catch( Exception e ) {
        _ARB_get_texture_sub_image = false;
        if( doThrow ) throw e;
    }
}

// KHR_robustness
// ARB_shader_texture_image_samples
private __gshared bool _ARB_shader_texture_image_samples;
@nogc bool ARB_shader_texture_image_samples() nothrow @property { return _ARB_shader_texture_image_samples; }

// ARB_texture_barrier